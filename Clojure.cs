/* Generated by Clojure */

namespace clojure.lib {

using System;

using org.clojure.runtime;

public class Clojure{
/* Generated by Clojure from the following Lisp:

(defn* apply ((fn & args+) (.applyTo fn __tld (spread* args+))))

*/

 public class apply : RestFn1{
override public Object doInvoke(ThreadLocalData __tld, Object fn, Cons argsPLUS__)  
{
if(__tld == null) __tld = ThreadLocalData.get();
return ((IFn)ACC__clojure__applyTo).invoke(__tld, fn, clojure____tld.getValue(__tld), clojure__spreadSTAR__.fn.invoke(__tld, argsPLUS__));
}
}
/* Generated by Clojure from the following Lisp:

(defn* complement ((fn) (fn (& args) (not (apply fn args)))))

*/

 public class complement : AFn{
override public Object invoke(ThreadLocalData __tld, Object fn)  
{
return (new FN__2163(fn));
}
 public class FN__2163 : RestFn0{
Object fn;
public FN__2163 (Object fn){
this.fn = fn;
}
override public Object doInvoke(ThreadLocalData __tld, Cons args)  
{
return ((clojure__apply.fn.invoke(__tld, fn, args))==null?RT.T:null);
}
}
}
/* Generated by Clojure from the following Lisp:

(defn* constantly ((x) (fn (& args) x)))

*/

 public class constantly : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
return (new FN__2164(x));
}
 public class FN__2164 : RestFn0{
Object x;
public FN__2164 (Object x){
this.x = x;
}
override public Object doInvoke(ThreadLocalData __tld, Cons args)  
{
return x;
}
}
}
/* Generated by Clojure from the following Lisp:

(defn* identity ((x) x))

*/

 public class identity : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
return x;
}
}
/* Generated by Clojure from the following Lisp:

(defn* eq ((x y) (RT.eq x y)))

*/

 public class eq : AFn{
override public Object invoke(ThreadLocalData __tld, Object x, Object y)  
{
return Reflector.invokeStaticMethod("eq","org.clojure.runtime.RT",new Object[]{x,y});
}
}
/* Generated by Clojure from the following Lisp:

(defn* eql ((x y) (RT.eql x y)))

*/

 public class eql : AFn{
override public Object invoke(ThreadLocalData __tld, Object x, Object y)  
{
return Reflector.invokeStaticMethod("eql","org.clojure.runtime.RT",new Object[]{x,y});
}
}
/* Generated by Clojure from the following Lisp:

(defn* equal ((x y) (RT.equal x y)))

*/

 public class equal : AFn{
override public Object invoke(ThreadLocalData __tld, Object x, Object y)  
{
return Reflector.invokeStaticMethod("equal","org.clojure.runtime.RT",new Object[]{x,y});
}
}
/* Generated by Clojure from the following Lisp:

(defn* equals ((x y) (.Equals x y)))

*/

 public class equals : AFn{
override public Object invoke(ThreadLocalData __tld, Object x, Object y)  
{
return ((IFn)ACC__clojure__Equals).invoke(__tld, x, y);
}
}
/* Generated by Clojure from the following Lisp:

(defn* not ((x) (if x nil t)))

*/

 public class not : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
if(x != null)
{
return null;
}
else
{
return RT.T;
}
}
}
/* Generated by Clojure from the following Lisp:

(defn* null? ((x) (if x nil t)))

*/

 public class nullQMARK__ : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
if(x != null)
{
return null;
}
else
{
return RT.T;
}
}
}
/* Generated by Clojure from the following Lisp:

(defn* acons ((key val alist) (cons (cons key val) alist)))

*/

 public class acons : AFn{
override public Object invoke(ThreadLocalData __tld, Object key, Object val, Object alist)  
{
return clojure__cons.fn.invoke(__tld, clojure__cons.fn.invoke(__tld, key, val), alist);
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 adjoin
 ((x list) (if (member x list) list (cons x list)))
 ((x list keys) (if (member x list keys) list (cons x list))))

*/

 public class adjoin : AFn{
override public Object invoke(ThreadLocalData __tld, Object x, Object list)  
{
if(clojure__member.fn.invoke(__tld, x, list) != null)
{
return list;
}
else
{
return clojure__cons.fn.invoke(__tld, x, list);
}
}
override public Object invoke(ThreadLocalData __tld, Object x, Object list, Object keys)  
{
if(clojure__member.fn.invoke(__tld, x, list, keys) != null)
{
return list;
}
else
{
return clojure__cons.fn.invoke(__tld, x, list);
}
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 append
 (NIL nil)
 ((first) first)
 ((first & rest) (nconc (copy-list first) (apply append rest))))

*/

 public class append : RestFn1{
override public Object invoke(ThreadLocalData __tld)  
{
return null;
}
override public Object invoke(ThreadLocalData __tld, Object first)  
{
return first;
}
override public Object doInvoke(ThreadLocalData __tld, Object first, Cons rest)  
{
if(__tld == null) __tld = ThreadLocalData.get();
return clojure__nconc.fn.invoke(__tld, clojure__copy_list.fn.invoke(__tld, first), clojure__apply.fn.invoke(__tld, clojure__append.getValue(__tld), rest));
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 assoc
 ((item alist) (assoc item alist nil))
 ((item alist keys)
  (assoc-if (fn (y) ((or (:test keys) eql) item y)) alist keys)))

*/

 public class assoc : AFn{
override public Object invoke(ThreadLocalData __tld, Object item, Object alist)  
{
return clojure__assoc.fn.invoke(__tld, item, alist, null);
}
override public Object invoke(ThreadLocalData __tld, Object item, Object alist, Object keys)  
{
if(__tld == null) __tld = ThreadLocalData.get();
Object G2165__1;
return clojure__assoc_if.fn.invoke(__tld, clojure__fn.fn.invoke(__tld, clojure__y.fn.invoke(__tld), ((IFn)((((G2165__1 = ((IFn)KEY__test).invoke(__tld, keys)) != null)||((G2165__1 = clojure__eql.getValue(__tld)) != null))?G2165__1:null)).invoke(__tld, item, clojure__y.getValue(__tld))), alist, keys);
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 assoc-if
 ((fun alist) (assoc-if fun alist nil))
 ((fun alist keys)
  (cond ((atom? alist) nil)
        ((and
          (cons? (first alist))
          (fun
           (if
            (:key keys)
            ((:key keys) (ffirst alist))
            (ffirst alist))))
         (first alist))
        (t (assoc-if fun (rest alist) keys)))))

*/

 public class assoc_if : AFn{
override public Object invoke(ThreadLocalData __tld, Object fun, Object alist)  
{
return clojure__assoc_if.fn.invoke(__tld, fun, alist, null);
}
override public Object invoke(ThreadLocalData __tld, Object fun, Object alist, Object keys)  
{
if(clojure__atomQMARK__.fn.invoke(__tld, alist) != null)
{
return null;
}
else
{
if((((clojure__consQMARK__.fn.invoke(__tld, clojure__first.fn.invoke(__tld, alist)) != null))?((IFn)fun).invoke(__tld, (((IFn)KEY__key).invoke(__tld, keys) != null?((IFn)((IFn)KEY__key).invoke(__tld, keys)).invoke(__tld, clojure__ffirst.fn.invoke(__tld, alist)):clojure__ffirst.fn.invoke(__tld, alist))):null) != null)
{
return clojure__first.fn.invoke(__tld, alist);
}
else
{
return clojure__assoc_if.fn.invoke(__tld, fun, clojure__rest.fn.invoke(__tld, alist), keys);
}
}
}
}
/* Generated by Clojure from the following Lisp:

(defn* atom? ((x) (not (cons? x))))

*/

 public class atomQMARK__ : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
return ((clojure__consQMARK__.fn.invoke(__tld, x))==null?RT.T:null);
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 butlast
 ((list) (butlast list 1))
 ((list n) (nreverse (nthcdr n (reverse list)))))

*/

 public class butlast : AFn{
override public Object invoke(ThreadLocalData __tld, Object list)  
{
return clojure__butlast.fn.invoke(__tld, list, Num.ONE);
}
override public Object invoke(ThreadLocalData __tld, Object list, Object n)  
{
return clojure__nreverse.fn.invoke(__tld, clojure__nthcdr.fn.invoke(__tld, n, clojure__reverse.fn.invoke(__tld, list)));
}
}
/* Generated by Clojure from the following Lisp:

(defn* first ((x) (when x (.first x))))

*/

 public class first : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
if(x != null)
{
return ((IFn)ACC__clojure__first).invoke(__tld, x);
}
else
{
return null;
}
}
}
/* Generated by Clojure from the following Lisp:

(defn* rest ((x) (when x (.rest x))))

*/

 public class rest : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
if(x != null)
{
return ((IFn)ACC__clojure__rest).invoke(__tld, x);
}
else
{
return null;
}
}
}
/* Generated by Clojure from the following Lisp:

(defn* ffirst ((x) (when x (first (first x)))))

*/

 public class ffirst : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
if(x != null)
{
return clojure__first.fn.invoke(__tld, clojure__first.fn.invoke(__tld, x));
}
else
{
return null;
}
}
}
/* Generated by Clojure from the following Lisp:

(defn* frest ((x) (when x (first (rest x)))))

*/

 public class frest : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
if(x != null)
{
return clojure__first.fn.invoke(__tld, clojure__rest.fn.invoke(__tld, x));
}
else
{
return null;
}
}
}
/* Generated by Clojure from the following Lisp:

(defn* rrest ((x) (when x (rest (rest x)))))

*/

 public class rrest : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
if(x != null)
{
return clojure__rest.fn.invoke(__tld, clojure__rest.fn.invoke(__tld, x));
}
else
{
return null;
}
}
}
/* Generated by Clojure from the following Lisp:

(defn* cons ((x y) (RT.cons x y)))

*/

 public class cons : AFn{
override public Object invoke(ThreadLocalData __tld, Object x, Object y)  
{
return Reflector.invokeStaticMethod("cons","org.clojure.runtime.RT",new Object[]{x,y});
}
}
/* Generated by Clojure from the following Lisp:

(defn* cons? ((x) (instance? x Cons.)))

*/

 public class consQMARK__ : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
return (x is org.clojure.runtime.Cons?RT.T:null);
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 copy-list
 ((list)
  (letfn
   ((cl (x) (if (atom? x) x (cons (first x) (cl (rest x))))))
   (cons (first list) (cl (rest list))))))

*/

 public class copy_list : AFn{
override public Object invoke(ThreadLocalData __tld, Object list)  
{
Box cl__1 = new Box(null);
cl__1.val = (new FN__2166(cl__1));
return clojure__cons.fn.invoke(__tld, clojure__first.fn.invoke(__tld, list), ((IFn)cl__1.val).invoke(__tld, clojure__rest.fn.invoke(__tld, list)));
}
 public class FN__2166 : AFn{
Box cl__1;
public FN__2166 (Box cl__1){
this.cl__1 = cl__1;
}
override public Object invoke(ThreadLocalData __tld, Object x)  
{
if(clojure__atomQMARK__.fn.invoke(__tld, x) != null)
{
return x;
}
else
{
return clojure__cons.fn.invoke(__tld, clojure__first.fn.invoke(__tld, x), ((IFn)cl__1.val).invoke(__tld, clojure__rest.fn.invoke(__tld, x)));
}
}
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 copy-tree
 ((tree)
  (if
   (atom? tree)
   tree
   (cons (copy-tree (first tree)) (copy-tree (rest tree))))))

*/

 public class copy_tree : AFn{
override public Object invoke(ThreadLocalData __tld, Object tree)  
{
if(clojure__atomQMARK__.fn.invoke(__tld, tree) != null)
{
return tree;
}
else
{
return clojure__cons.fn.invoke(__tld, clojure__copy_tree.fn.invoke(__tld, clojure__first.fn.invoke(__tld, tree)), clojure__copy_tree.fn.invoke(__tld, clojure__rest.fn.invoke(__tld, tree)));
}
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 last
 ((list) (last list 1))
 ((list n)
  (do ((l list (rest l)) (r list) (i 0 (1+ i)))
      ((null? l) r)
      (if (>= i n) (pop r)))))

*/

 public class last : AFn{
override public Object invoke(ThreadLocalData __tld, Object list)  
{
return clojure__last.fn.invoke(__tld, list, Num.ONE);
}
override public Object invoke(ThreadLocalData __tld, Object list, Object n)  
{
Object G2169__1;
Object G2168__2;
Object G2167__3;
Object i__4;
Object r__5;
Object l__6;
l__6 = list;
r__5 = list;
i__4 = Num.ZERO;
for(;;)
{
if(clojure__nullQMARK__.fn.invoke(__tld, l__6) != null)
{
return r__5;
}
if(COMMON_LISP__GT__EQ__.fn.invoke(__tld, i__4, n) != null)
{
clojure__pop.fn.invoke(__tld, r__5);
}
G2167__3 = clojure__rest.fn.invoke(__tld, l__6);
G2168__2 = null;
G2169__1 = COMMON_LISP__NUM__1PLUS__.fn.invoke(__tld, i__4);
l__6 = G2167__3;
r__5 = G2168__2;
i__4 = G2169__1;
}
}
}
/* Generated by Clojure from the following Lisp:

(defn* list ((&rest args) args))

*/

 public class list : AFn{
override public Object invoke(ThreadLocalData __tld, Object AMP__rest, Object args)  
{
return args;
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 spread*
 ((args)
  (cond ((null? args) nil)
        ((null? (rest args)) (first args))
        (t (cons (first args) (rest (rest args)))))))

*/

 public class spreadSTAR__ : AFn{
override public Object invoke(ThreadLocalData __tld, Object args)  
{
if(clojure__nullQMARK__.fn.invoke(__tld, args) != null)
{
return null;
}
else
{
if(clojure__nullQMARK__.fn.invoke(__tld, clojure__rest.fn.invoke(__tld, args)) != null)
{
return clojure__first.fn.invoke(__tld, args);
}
else
{
return clojure__cons.fn.invoke(__tld, clojure__first.fn.invoke(__tld, args), clojure__rest.fn.invoke(__tld, clojure__rest.fn.invoke(__tld, args)));
}
}
}
}
/* Generated by Clojure from the following Lisp:

(defn* list* ((& args) (spread* args)))

*/

 public class listSTAR__ : RestFn0{
override public Object doInvoke(ThreadLocalData __tld, Cons args)  
{
return clojure__spreadSTAR__.fn.invoke(__tld, args);
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 +
 (NIL 0)
 ((x) x)
 ((x y) (Num.add x y))
 ((x y & nums) (Num.add (Num.add x y) (apply + nums))))

*/

 public class PLUS__ : RestFn2{
override public Object invoke(ThreadLocalData __tld)  
{
return Num.ZERO;
}
override public Object invoke(ThreadLocalData __tld, Object x)  
{
return x;
}
override public Object invoke(ThreadLocalData __tld, Object x, Object y)  
{
return Reflector.invokeStaticMethod("add","org.clojure.runtime.Num",new Object[]{x,y});
}
override public Object doInvoke(ThreadLocalData __tld, Object x, Object y, Cons nums)  
{
if(__tld == null) __tld = ThreadLocalData.get();
return Reflector.invokeStaticMethod("add","org.clojure.runtime.Num",new Object[]{Reflector.invokeStaticMethod("add","org.clojure.runtime.Num",new Object[]{x,y}),clojure__apply.fn.invoke(__tld, COMMON_LISP__PLUS__.getValue(__tld), nums)});
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 -
 ((x) (Num.negate x))
 ((x y) (Num.subtract x y))
 ((x y & nums) (apply - (Num.subtract x y) nums)))

*/

 public class _ : RestFn2{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
return Reflector.invokeStaticMethod("negate","org.clojure.runtime.Num",new Object[]{x});
}
override public Object invoke(ThreadLocalData __tld, Object x, Object y)  
{
return Reflector.invokeStaticMethod("subtract","org.clojure.runtime.Num",new Object[]{x,y});
}
override public Object doInvoke(ThreadLocalData __tld, Object x, Object y, Cons nums)  
{
if(__tld == null) __tld = ThreadLocalData.get();
return clojure__apply.fn.invoke(__tld, COMMON_LISP___.getValue(__tld), Reflector.invokeStaticMethod("subtract","org.clojure.runtime.Num",new Object[]{x,y}), nums);
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 *
 (NIL 1)
 ((x) x)
 ((x y) (Num.multiply x y))
 ((x y & nums) (Num.multiply (Num.multiply x y) (apply + nums))))

*/

 public class STAR__ : RestFn2{
override public Object invoke(ThreadLocalData __tld)  
{
return Num.ONE;
}
override public Object invoke(ThreadLocalData __tld, Object x)  
{
return x;
}
override public Object invoke(ThreadLocalData __tld, Object x, Object y)  
{
return Reflector.invokeStaticMethod("multiply","org.clojure.runtime.Num",new Object[]{x,y});
}
override public Object doInvoke(ThreadLocalData __tld, Object x, Object y, Cons nums)  
{
if(__tld == null) __tld = ThreadLocalData.get();
return Reflector.invokeStaticMethod("multiply","org.clojure.runtime.Num",new Object[]{Reflector.invokeStaticMethod("multiply","org.clojure.runtime.Num",new Object[]{x,y}),clojure__apply.fn.invoke(__tld, COMMON_LISP__PLUS__.getValue(__tld), nums)});
}
}
/* Generated by Clojure from the following Lisp:

(defn* 1+ ((x) (.onePlus x)))

*/

 public class NUM__1PLUS__ : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
return ((IFn)ACC__clojure__onePlus).invoke(__tld, x);
}
}
/* Generated by Clojure from the following Lisp:

(defn* 1- ((x) (.oneMinus x)))

*/

 public class NUM__1_ : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
return ((IFn)ACC__clojure__oneMinus).invoke(__tld, x);
}
}
/* Generated by Clojure from the following Lisp:

(defn* integer? ((x) (instance? x IntegerNum.)))

*/

 public class integerQMARK__ : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
return (x is org.clojure.runtime.IntegerNum?RT.T:null);
}
}
/* Generated by Clojure from the following Lisp:

(defn* neg? ((x) (.minusp x)))

*/

 public class negQMARK__ : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
return ((IFn)ACC__clojure__minusp).invoke(__tld, x);
}
}
/* Generated by Clojure from the following Lisp:

(defn* num? ((x) (instance? x Num.)))

*/

 public class numQMARK__ : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
return (x is org.clojure.runtime.Num?RT.T:null);
}
}
/* Generated by Clojure from the following Lisp:

(defn* pos? ((x) (.plusp x)))

*/

 public class posQMARK__ : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
return ((IFn)ACC__clojure__plusp).invoke(__tld, x);
}
}
/* Generated by Clojure from the following Lisp:

(defn* zerop ((x) (= x Num.ZERO)))

*/

 public class zerop : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
return COMMON_LISP__EQ__.fn.invoke(__tld, x, Reflector.getStaticField("ZERO","org.clojure.runtime.Num"));
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 =
 ((x) t)
 ((x y) (Num.equiv x y))
 ((x y & rest) (and (Num.equiv x y) (apply = y rest))))

*/

 public class EQ__ : RestFn2{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
return RT.T;
}
override public Object invoke(ThreadLocalData __tld, Object x, Object y)  
{
return Reflector.invokeStaticMethod("equiv","org.clojure.runtime.Num",new Object[]{x,y});
}
override public Object doInvoke(ThreadLocalData __tld, Object x, Object y, Cons rest)  
{
if(__tld == null) __tld = ThreadLocalData.get();
return (((Reflector.invokeStaticMethod("equiv","org.clojure.runtime.Num",new Object[]{x,y}) != null))?clojure__apply.fn.invoke(__tld, COMMON_LISP__EQ__.getValue(__tld), y, rest):null);
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 <
 ((X) T)
 ((X Y) (Num.lt X Y))
 ((X Y & REST) (and (Num.lt X Y) (apply < Y REST))))

*/

 public class LT__ : RestFn2{
override public Object invoke(ThreadLocalData __tld, Object X)  
{
if(__tld == null) __tld = ThreadLocalData.get();
return COMMON_LISP__T.getValue(__tld);
}
override public Object invoke(ThreadLocalData __tld, Object X, Object Y)  
{
return Reflector.invokeStaticMethod("lt","org.clojure.runtime.Num",new Object[]{X,Y});
}
override public Object doInvoke(ThreadLocalData __tld, Object X, Object Y, Cons REST)  
{
if(__tld == null) __tld = ThreadLocalData.get();
return (((Reflector.invokeStaticMethod("lt","org.clojure.runtime.Num",new Object[]{X,Y}) != null))?clojure__apply.fn.invoke(__tld, COMMON_LISP__LT__.getValue(__tld), Y, REST):null);
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 <=
 ((X) T)
 ((X Y) (Num.lte X Y))
 ((X Y & REST) (and (Num.lte X Y) (apply <= Y REST))))

*/

 public class LT__EQ__ : RestFn2{
override public Object invoke(ThreadLocalData __tld, Object X)  
{
if(__tld == null) __tld = ThreadLocalData.get();
return COMMON_LISP__T.getValue(__tld);
}
override public Object invoke(ThreadLocalData __tld, Object X, Object Y)  
{
return Reflector.invokeStaticMethod("lte","org.clojure.runtime.Num",new Object[]{X,Y});
}
override public Object doInvoke(ThreadLocalData __tld, Object X, Object Y, Cons REST)  
{
if(__tld == null) __tld = ThreadLocalData.get();
return (((Reflector.invokeStaticMethod("lte","org.clojure.runtime.Num",new Object[]{X,Y}) != null))?clojure__apply.fn.invoke(__tld, COMMON_LISP__LT__EQ__.getValue(__tld), Y, REST):null);
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 >
 ((X) T)
 ((X Y) (Num.gt X Y))
 ((X Y & REST) (and (Num.gt X Y) (apply > Y REST))))

*/

 public class GT__ : RestFn2{
override public Object invoke(ThreadLocalData __tld, Object X)  
{
if(__tld == null) __tld = ThreadLocalData.get();
return COMMON_LISP__T.getValue(__tld);
}
override public Object invoke(ThreadLocalData __tld, Object X, Object Y)  
{
return Reflector.invokeStaticMethod("gt","org.clojure.runtime.Num",new Object[]{X,Y});
}
override public Object doInvoke(ThreadLocalData __tld, Object X, Object Y, Cons REST)  
{
if(__tld == null) __tld = ThreadLocalData.get();
return (((Reflector.invokeStaticMethod("gt","org.clojure.runtime.Num",new Object[]{X,Y}) != null))?clojure__apply.fn.invoke(__tld, COMMON_LISP__GT__.getValue(__tld), Y, REST):null);
}
}
/* Generated by Clojure from the following Lisp:

(defn*
 >=
 ((X) T)
 ((X Y) (Num.gte X Y))
 ((X Y & REST) (and (Num.gte X Y) (apply >= Y REST))))

*/

 public class GT__EQ__ : RestFn2{
override public Object invoke(ThreadLocalData __tld, Object X)  
{
if(__tld == null) __tld = ThreadLocalData.get();
return COMMON_LISP__T.getValue(__tld);
}
override public Object invoke(ThreadLocalData __tld, Object X, Object Y)  
{
return Reflector.invokeStaticMethod("gte","org.clojure.runtime.Num",new Object[]{X,Y});
}
override public Object doInvoke(ThreadLocalData __tld, Object X, Object Y, Cons REST)  
{
if(__tld == null) __tld = ThreadLocalData.get();
return (((Reflector.invokeStaticMethod("gte","org.clojure.runtime.Num",new Object[]{X,Y}) != null))?clojure__apply.fn.invoke(__tld, COMMON_LISP__GT__EQ__.getValue(__tld), Y, REST):null);
}
}
/* Generated by Clojure from the following Lisp:

(defn* prn ((x) (Console.WriteLine x)))

*/

 public class prn : AFn{
override public Object invoke(ThreadLocalData __tld, Object x)  
{
return Reflector.invokeStaticMethod("WriteLine","System.Console",new Object[]{x});
}
}
/* Generated by Clojure from the following Lisp:

(defn* fact ((n) (if (= n 1) 1 (* n (fact (1- n))))))

*/

 public class fact : AFn{
override public Object invoke(ThreadLocalData __tld, Object n)  
{
if(COMMON_LISP__EQ__.fn.invoke(__tld, n, Num.ONE) != null)
{
return Num.ONE;
}
else
{
return COMMON_LISP__STAR__.fn.invoke(__tld, n, clojure__fact.fn.invoke(__tld, COMMON_LISP__NUM__1_.fn.invoke(__tld, n)));
}
}
}
/* Generated by Clojure from the following Lisp:

(defn* fmain ((args) (prn (fact 50))))

*/

 public class fmain : AFn{
override public Object invoke(ThreadLocalData __tld, Object args)  
{
return clojure__prn.fn.invoke(__tld, clojure__fact.fn.invoke(__tld, Num.from(50)));
}
}
/* Generated by Clojure from the following Lisp:

(defmain fmain)

*/

static public void Main(String[] args){
try{
clojure__fmain.fn.invoke(ThreadLocalData.get(),args);
}
catch(Exception ex){}
}
static Symbol SYM__t = Symbol.intern("t");
static Keyword KEY__key = Keyword.intern("key");
static Keyword KEY__test = Keyword.intern("test");
static Var clojure__fmain = Namespace.internVar("clojure","fmain");
static Var clojure__prn = Namespace.internVar("clojure","prn");
static Var COMMON_LISP__NUM__1_ = Namespace.internVar("COMMON_LISP","NUM__1_");
static Var clojure__fact = Namespace.internVar("clojure","fact");
static Var COMMON_LISP__STAR__ = Namespace.internVar("COMMON_LISP","STAR__");
static Var COMMON_LISP__GT__ = Namespace.internVar("COMMON_LISP","GT__");
static Var COMMON_LISP__LT__EQ__ = Namespace.internVar("COMMON_LISP","LT__EQ__");
static Var COMMON_LISP__LT__ = Namespace.internVar("COMMON_LISP","LT__");
static Var COMMON_LISP__T = Namespace.internVar("COMMON_LISP","T");
static Var COMMON_LISP__EQ__ = Namespace.internVar("COMMON_LISP","EQ__");
static Var COMMON_LISP___ = Namespace.internVar("COMMON_LISP","_");
static Var COMMON_LISP__PLUS__ = Namespace.internVar("COMMON_LISP","PLUS__");
static Var COMMON_LISP__NUM__1PLUS__ = Namespace.internVar("COMMON_LISP","NUM__1PLUS__");
static Var clojure__pop = Namespace.internVar("clojure","pop");
static Var COMMON_LISP__GT__EQ__ = Namespace.internVar("COMMON_LISP","GT__EQ__");
static Var clojure__nullQMARK__ = Namespace.internVar("clojure","nullQMARK__");
static Var clojure__last = Namespace.internVar("clojure","last");
static Var clojure__copy_tree = Namespace.internVar("clojure","copy_tree");
static Var clojure__reverse = Namespace.internVar("clojure","reverse");
static Var clojure__nthcdr = Namespace.internVar("clojure","nthcdr");
static Var clojure__nreverse = Namespace.internVar("clojure","nreverse");
static Var clojure__butlast = Namespace.internVar("clojure","butlast");
static Var clojure__rest = Namespace.internVar("clojure","rest");
static Var clojure__ffirst = Namespace.internVar("clojure","ffirst");
static Var clojure__first = Namespace.internVar("clojure","first");
static Var clojure__consQMARK__ = Namespace.internVar("clojure","consQMARK__");
static Var clojure__atomQMARK__ = Namespace.internVar("clojure","atomQMARK__");
static Var clojure__eql = Namespace.internVar("clojure","eql");
static Var clojure__y = Namespace.internVar("clojure","y");
static Var clojure__fn = Namespace.internVar("clojure","fn");
static Var clojure__assoc_if = Namespace.internVar("clojure","assoc_if");
static Var clojure__assoc = Namespace.internVar("clojure","assoc");
static Var clojure__append = Namespace.internVar("clojure","append");
static Var clojure__copy_list = Namespace.internVar("clojure","copy_list");
static Var clojure__nconc = Namespace.internVar("clojure","nconc");
static Var clojure__member = Namespace.internVar("clojure","member");
static Var clojure__cons = Namespace.internVar("clojure","cons");
static Var clojure__apply = Namespace.internVar("clojure","apply");
static Var clojure__spreadSTAR__ = Namespace.internVar("clojure","spreadSTAR__");
static Var clojure____tld = Namespace.internVar("clojure","__tld");
static Accessor ACC__clojure__plusp = Namespace.internAccessor("clojure","plusp");
static Accessor ACC__clojure__minusp = Namespace.internAccessor("clojure","minusp");
static Accessor ACC__clojure__oneMinus = Namespace.internAccessor("clojure","oneMinus");
static Accessor ACC__clojure__onePlus = Namespace.internAccessor("clojure","onePlus");
static Accessor ACC__clojure__rest = Namespace.internAccessor("clojure","rest");
static Accessor ACC__clojure__first = Namespace.internAccessor("clojure","first");
static Accessor ACC__clojure__Equals = Namespace.internAccessor("clojure","Equals");
static Accessor ACC__clojure__applyTo = Namespace.internAccessor("clojure","applyTo");
static Clojure(){
try{
Namespace.internVar("clojure","fmain").bind(new fmain());
Namespace.internVar("clojure","fact").bind(new fact());
Namespace.internVar("clojure","prn").bind(new prn());
Namespace.internVar("COMMON_LISP","GT__EQ__").bind(new GT__EQ__());
Namespace.internVar("COMMON_LISP","GT__").bind(new GT__());
Namespace.internVar("COMMON_LISP","LT__EQ__").bind(new LT__EQ__());
Namespace.internVar("COMMON_LISP","LT__").bind(new LT__());
Namespace.internVar("COMMON_LISP","EQ__").bind(new EQ__());
Namespace.internVar("clojure","zerop").bind(new zerop());
Namespace.internVar("clojure","posQMARK__").bind(new posQMARK__());
Namespace.internVar("clojure","numQMARK__").bind(new numQMARK__());
Namespace.internVar("clojure","negQMARK__").bind(new negQMARK__());
Namespace.internVar("clojure","integerQMARK__").bind(new integerQMARK__());
Namespace.internVar("COMMON_LISP","NUM__1_").bind(new NUM__1_());
Namespace.internVar("COMMON_LISP","NUM__1PLUS__").bind(new NUM__1PLUS__());
Namespace.internVar("COMMON_LISP","STAR__").bind(new STAR__());
Namespace.internVar("COMMON_LISP","_").bind(new _());
Namespace.internVar("COMMON_LISP","PLUS__").bind(new PLUS__());
Namespace.internVar("clojure","listSTAR__").bind(new listSTAR__());
Namespace.internVar("clojure","spreadSTAR__").bind(new spreadSTAR__());
Namespace.internVar("clojure","list").bind(new list());
Namespace.internVar("clojure","last").bind(new last());
Namespace.internVar("clojure","copy_tree").bind(new copy_tree());
Namespace.internVar("clojure","copy_list").bind(new copy_list());
Namespace.internVar("clojure","consQMARK__").bind(new consQMARK__());
Namespace.internVar("clojure","cons").bind(new cons());
Namespace.internVar("clojure","rrest").bind(new rrest());
Namespace.internVar("clojure","frest").bind(new frest());
Namespace.internVar("clojure","ffirst").bind(new ffirst());
Namespace.internVar("clojure","rest").bind(new rest());
Namespace.internVar("clojure","first").bind(new first());
Namespace.internVar("clojure","butlast").bind(new butlast());
Namespace.internVar("clojure","atomQMARK__").bind(new atomQMARK__());
Namespace.internVar("clojure","assoc_if").bind(new assoc_if());
Namespace.internVar("clojure","assoc").bind(new assoc());
Namespace.internVar("clojure","append").bind(new append());
Namespace.internVar("clojure","adjoin").bind(new adjoin());
Namespace.internVar("clojure","acons").bind(new acons());
Namespace.internVar("clojure","nullQMARK__").bind(new nullQMARK__());
Namespace.internVar("clojure","not").bind(new not());
Namespace.internVar("clojure","equals").bind(new equals());
Namespace.internVar("clojure","equal").bind(new equal());
Namespace.internVar("clojure","eql").bind(new eql());
Namespace.internVar("clojure","eq").bind(new eq());
Namespace.internVar("clojure","identity").bind(new identity());
Namespace.internVar("clojure","constantly").bind(new constantly());
Namespace.internVar("clojure","complement").bind(new complement());
Namespace.internVar("clojure","apply").bind(new apply());
}catch(Exception e){}
}
public static void __init(){}
}
}
