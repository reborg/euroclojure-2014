/* Generated by Clojure */

package clojure.lib;

import org.clojure.runtime.*;

public class Clojure {
/* Generated by Clojure from the following Lisp:

(defn* apply ((fn & args+) (.applyTo fn __tld (spread* args+))))

*/

    static public class apply extends RestFn1 {
        public Object doInvoke(ThreadLocalData __tld, Object fn, Cons argsPLUS__) throws Exception {
            if (__tld == null) __tld = ThreadLocalData.get();
            return ((IFn) ACC__clojure__applyTo).invoke(__tld, fn, clojure____tld.getValue(__tld), clojure__spreadSTAR__.fn.invoke(__tld, argsPLUS__));
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* complement ((fn) (fn (& args) (not (apply fn args)))))

*/

    static public class complement extends AFn {
        public Object invoke(ThreadLocalData __tld, Object fn) throws Exception {
            return (new FN__3658(fn));
        }

        static public class FN__3658 extends RestFn0 {
            Object fn;

            public FN__3658(Object fn) {
                this.fn = fn;
            }

            public Object doInvoke(ThreadLocalData __tld, Cons args) throws Exception {
                return ((clojure__apply.fn.invoke(__tld, fn, args)) == null ? RT.T : null);
            }
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* constantly ((x) (fn (& args) x)))

*/

    static public class constantly extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            return (new FN__3659(x));
        }

        static public class FN__3659 extends RestFn0 {
            Object x;

            public FN__3659(Object x) {
                this.x = x;
            }

            public Object doInvoke(ThreadLocalData __tld, Cons args) throws Exception {
                return x;
            }
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* identity ((x) x))

*/

    static public class identity extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            return x;
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* eq ((x y) (RT.eq x y)))

*/

    static public class eq extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x, Object y) throws Exception {
            return Reflector.invokeStaticMethod("eq", "org.clojure.runtime.RT", new Object[]{x, y});
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* eql ((x y) (RT.eql x y)))

*/

    static public class eql extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x, Object y) throws Exception {
            return Reflector.invokeStaticMethod("eql", "org.clojure.runtime.RT", new Object[]{x, y});
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* equal ((x y) (RT.equal x y)))

*/

    static public class equal extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x, Object y) throws Exception {
            return Reflector.invokeStaticMethod("equal", "org.clojure.runtime.RT", new Object[]{x, y});
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* equals ((x y) (.equals x y)))

*/

    static public class equals extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x, Object y) throws Exception {
            return ((IFn) ACC__clojure__equals).invoke(__tld, x, y);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* not ((x) (if x nil t)))

*/

    static public class not extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            if (x != null) {
                return null;
            } else {
                return RT.T;
            }
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* null? ((x) (if x nil t)))

*/

    static public class nullQMARK__ extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            if (x != null) {
                return null;
            } else {
                return RT.T;
            }
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* acons ((key val alist) (cons (cons key val) alist)))

*/

    static public class acons extends AFn {
        public Object invoke(ThreadLocalData __tld, Object key, Object val, Object alist) throws Exception {
            return clojure__cons.fn.invoke(__tld, clojure__cons.fn.invoke(__tld, key, val), alist);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 adjoin
 ((x list) (if (member x list) list (cons x list)))
 ((x list keys) (if (member x list keys) list (cons x list))))

*/

    static public class adjoin extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x, Object list) throws Exception {
            if (clojure__member.fn.invoke(__tld, x, list) != null) {
                return list;
            } else {
                return clojure__cons.fn.invoke(__tld, x, list);
            }
        }

        public Object invoke(ThreadLocalData __tld, Object x, Object list, Object keys) throws Exception {
            if (clojure__member.fn.invoke(__tld, x, list, keys) != null) {
                return list;
            } else {
                return clojure__cons.fn.invoke(__tld, x, list);
            }
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 append
 (NIL nil)
 ((first) first)
 ((first & rest) (nconc (copy-list first) (apply append rest))))

*/

    static public class append extends RestFn1 {
        public Object invoke(ThreadLocalData __tld) throws Exception {
            return null;
        }

        public Object invoke(ThreadLocalData __tld, Object first) throws Exception {
            return first;
        }

        public Object doInvoke(ThreadLocalData __tld, Object first, Cons rest) throws Exception {
            if (__tld == null) __tld = ThreadLocalData.get();
            return clojure__nconc.fn.invoke(__tld, clojure__copy_list.fn.invoke(__tld, first), clojure__apply.fn.invoke(__tld, clojure__append.getValue(__tld), rest));
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 assoc
 ((item alist) (assoc item alist nil))
 ((item alist keys)
  (assoc-if (fn (y) ((or (:test keys) eql) item y)) alist keys)))

*/

    static public class assoc extends AFn {
        public Object invoke(ThreadLocalData __tld, Object item, Object alist) throws Exception {
            return clojure__assoc.fn.invoke(__tld, item, alist, null);
        }

        public Object invoke(ThreadLocalData __tld, Object item, Object alist, Object keys) throws Exception {
            if (__tld == null) __tld = ThreadLocalData.get();
            Object G3660__1;
            return clojure__assoc_if.fn.invoke(__tld, clojure__fn.fn.invoke(__tld, clojure__y.fn.invoke(__tld), ((IFn) ((((G3660__1 = ((IFn) KEY__test).invoke(__tld, keys)) != null) || ((G3660__1 = clojure__eql.getValue(__tld)) != null)) ? G3660__1 : null)).invoke(__tld, item, clojure__y.getValue(__tld))), alist, keys);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 assoc-if
 ((fun alist) (assoc-if fun alist nil))
 ((fun alist keys)
  (cond ((atom? alist) nil)
        ((and
          (cons? (first alist))
          (fun
           (if
            (:key keys)
            ((:key keys) (ffirst alist))
            (ffirst alist))))
         (first alist))
        (t (assoc-if fun (rest alist) keys)))))

*/

    static public class assoc_if extends AFn {
        public Object invoke(ThreadLocalData __tld, Object fun, Object alist) throws Exception {
            return clojure__assoc_if.fn.invoke(__tld, fun, alist, null);
        }

        public Object invoke(ThreadLocalData __tld, Object fun, Object alist, Object keys) throws Exception {
            if (clojure__atomQMARK__.fn.invoke(__tld, alist) != null) {
                return null;
            } else {
                if ((((clojure__consQMARK__.fn.invoke(__tld, clojure__first.fn.invoke(__tld, alist)) != null)) ? ((IFn) fun).invoke(__tld, (((IFn) KEY__key).invoke(__tld, keys) != null ? ((IFn) ((IFn) KEY__key).invoke(__tld, keys)).invoke(__tld, clojure__ffirst.fn.invoke(__tld, alist)) : clojure__ffirst.fn.invoke(__tld, alist))) : null) != null) {
                    return clojure__first.fn.invoke(__tld, alist);
                } else {
                    return clojure__assoc_if.fn.invoke(__tld, fun, clojure__rest.fn.invoke(__tld, alist), keys);
                }
            }
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* atom? ((x) (not (cons? x))))

*/

    static public class atomQMARK__ extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            return ((clojure__consQMARK__.fn.invoke(__tld, x)) == null ? RT.T : null);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 butlast
 ((list) (butlast list 1))
 ((list n) (nreverse (nthcdr n (reverse list)))))

*/

    static public class butlast extends AFn {
        public Object invoke(ThreadLocalData __tld, Object list) throws Exception {
            return clojure__butlast.fn.invoke(__tld, list, Num.ONE);
        }

        public Object invoke(ThreadLocalData __tld, Object list, Object n) throws Exception {
            return clojure__nreverse.fn.invoke(__tld, clojure__nthcdr.fn.invoke(__tld, n, clojure__reverse.fn.invoke(__tld, list)));
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* first ((x) (when x (.first x))))

*/

    static public class first extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            if (x != null) {
                return ((IFn) ACC__clojure__first).invoke(__tld, x);
            } else {
                return null;
            }
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* rest ((x) (when x (.rest x))))

*/

    static public class rest extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            if (x != null) {
                return ((IFn) ACC__clojure__rest).invoke(__tld, x);
            } else {
                return null;
            }
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* ffirst ((x) (when x (first (first x)))))

*/

    static public class ffirst extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            if (x != null) {
                return clojure__first.fn.invoke(__tld, clojure__first.fn.invoke(__tld, x));
            } else {
                return null;
            }
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* frest ((x) (when x (first (rest x)))))

*/

    static public class frest extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            if (x != null) {
                return clojure__first.fn.invoke(__tld, clojure__rest.fn.invoke(__tld, x));
            } else {
                return null;
            }
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* rrest ((x) (when x (rest (rest x)))))

*/

    static public class rrest extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            if (x != null) {
                return clojure__rest.fn.invoke(__tld, clojure__rest.fn.invoke(__tld, x));
            } else {
                return null;
            }
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* cons ((x y) (RT.cons x y)))

*/

    static public class cons extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x, Object y) throws Exception {
            return Reflector.invokeStaticMethod("cons", "org.clojure.runtime.RT", new Object[]{x, y});
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* cons? ((x) (instance? x Cons.)))

*/

    static public class consQMARK__ extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            return (x instanceof org.clojure.runtime.Cons ? RT.T : null);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 copy-list
 ((list)
  (letfn
   ((cl (x) (if (atom? x) x (cons (first x) (cl (rest x))))))
   (cons (first list) (cl (rest list))))))

*/

    static public class copy_list extends AFn {
        public Object invoke(ThreadLocalData __tld, Object list) throws Exception {
            Box cl__1 = new Box(null);
            cl__1.val = (new FN__3661(cl__1));
            return clojure__cons.fn.invoke(__tld, clojure__first.fn.invoke(__tld, list), ((IFn) cl__1.val).invoke(__tld, clojure__rest.fn.invoke(__tld, list)));
        }

        static public class FN__3661 extends AFn {
            Box cl__1;

            public FN__3661(Box cl__1) {
                this.cl__1 = cl__1;
            }

            public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
                if (clojure__atomQMARK__.fn.invoke(__tld, x) != null) {
                    return x;
                } else {
                    return clojure__cons.fn.invoke(__tld, clojure__first.fn.invoke(__tld, x), ((IFn) cl__1.val).invoke(__tld, clojure__rest.fn.invoke(__tld, x)));
                }
            }
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 copy-tree
 ((tree)
  (if
   (atom? tree)
   tree
   (cons (copy-tree (first tree)) (copy-tree (rest tree))))))

*/

    static public class copy_tree extends AFn {
        public Object invoke(ThreadLocalData __tld, Object tree) throws Exception {
            if (clojure__atomQMARK__.fn.invoke(__tld, tree) != null) {
                return tree;
            } else {
                return clojure__cons.fn.invoke(__tld, clojure__copy_tree.fn.invoke(__tld, clojure__first.fn.invoke(__tld, tree)), clojure__copy_tree.fn.invoke(__tld, clojure__rest.fn.invoke(__tld, tree)));
            }
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 last
 ((list) (last list 1))
 ((list n)
  (do ((l list (rest l)) (r list) (i 0 (1+ i)))
      ((null? l) r)
      (if (>= i n) (pop r)))))

*/

    static public class last extends AFn {
        public Object invoke(ThreadLocalData __tld, Object list) throws Exception {
            return clojure__last.fn.invoke(__tld, list, Num.ONE);
        }

        public Object invoke(ThreadLocalData __tld, Object list, Object n) throws Exception {
            Object G3664__1;
            Object G3663__2;
            Object G3662__3;
            Object i__4;
            Object r__5;
            Object l__6;
            l__6 = list;
            r__5 = list;
            i__4 = Num.ZERO;
            for (; ; ) {
                if (clojure__nullQMARK__.fn.invoke(__tld, l__6) != null) {
                    return r__5;
                }
                if (COMMON_LISP__GT__EQ__.fn.invoke(__tld, i__4, n) != null) {
                    clojure__pop.fn.invoke(__tld, r__5);
                }
                G3662__3 = clojure__rest.fn.invoke(__tld, l__6);
                G3663__2 = null;
                G3664__1 = COMMON_LISP__NUM__1PLUS__.fn.invoke(__tld, i__4);
                l__6 = G3662__3;
                r__5 = G3663__2;
                i__4 = G3664__1;
            }
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* list ((&rest args) args))

*/

    static public class list extends AFn {
        public Object invoke(ThreadLocalData __tld, Object AMP__rest, Object args) throws Exception {
            return args;
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 spread*
 ((args)
  (cond ((null? args) nil)
        ((null? (rest args)) (first args))
        (t (cons (first args) (rest (rest args)))))))

*/

    static public class spreadSTAR__ extends AFn {
        public Object invoke(ThreadLocalData __tld, Object args) throws Exception {
            if (clojure__nullQMARK__.fn.invoke(__tld, args) != null) {
                return null;
            } else {
                if (clojure__nullQMARK__.fn.invoke(__tld, clojure__rest.fn.invoke(__tld, args)) != null) {
                    return clojure__first.fn.invoke(__tld, args);
                } else {
                    return clojure__cons.fn.invoke(__tld, clojure__first.fn.invoke(__tld, args), clojure__rest.fn.invoke(__tld, clojure__rest.fn.invoke(__tld, args)));
                }
            }
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* list* ((& args) (spread* args)))

*/

    static public class listSTAR__ extends RestFn0 {
        public Object doInvoke(ThreadLocalData __tld, Cons args) throws Exception {
            return clojure__spreadSTAR__.fn.invoke(__tld, args);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 +
 (NIL 0)
 ((x) x)
 ((x y) (Num.add x y))
 ((x y & nums) (Num.add (Num.add x y) (apply + nums))))

*/

    static public class PLUS__ extends RestFn2 {
        public Object invoke(ThreadLocalData __tld) throws Exception {
            return Num.ZERO;
        }

        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            return x;
        }

        public Object invoke(ThreadLocalData __tld, Object x, Object y) throws Exception {
            return Reflector.invokeStaticMethod("add", "org.clojure.runtime.Num", new Object[]{x, y});
        }

        public Object doInvoke(ThreadLocalData __tld, Object x, Object y, Cons nums) throws Exception {
            if (__tld == null) __tld = ThreadLocalData.get();
            return Reflector.invokeStaticMethod("add", "org.clojure.runtime.Num", new Object[]{Reflector.invokeStaticMethod("add", "org.clojure.runtime.Num", new Object[]{x, y}), clojure__apply.fn.invoke(__tld, COMMON_LISP__PLUS__.getValue(__tld), nums)});
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 -
 ((x) (Num.negate x))
 ((x y) (Num.subtract x y))
 ((x y & nums) (apply - (Num.subtract x y) nums)))

*/

    static public class _ extends RestFn2 {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            return Reflector.invokeStaticMethod("negate", "org.clojure.runtime.Num", new Object[]{x});
        }

        public Object invoke(ThreadLocalData __tld, Object x, Object y) throws Exception {
            return Reflector.invokeStaticMethod("subtract", "org.clojure.runtime.Num", new Object[]{x, y});
        }

        public Object doInvoke(ThreadLocalData __tld, Object x, Object y, Cons nums) throws Exception {
            if (__tld == null) __tld = ThreadLocalData.get();
            return clojure__apply.fn.invoke(__tld, COMMON_LISP___.getValue(__tld), Reflector.invokeStaticMethod("subtract", "org.clojure.runtime.Num", new Object[]{x, y}), nums);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 *
 (NIL 1)
 ((x) x)
 ((x y) (Num.multiply x y))
 ((x y & nums) (Num.multiply (Num.multiply x y) (apply + nums))))

*/

    static public class STAR__ extends RestFn2 {
        public Object invoke(ThreadLocalData __tld) throws Exception {
            return Num.ONE;
        }

        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            return x;
        }

        public Object invoke(ThreadLocalData __tld, Object x, Object y) throws Exception {
            return Reflector.invokeStaticMethod("multiply", "org.clojure.runtime.Num", new Object[]{x, y});
        }

        public Object doInvoke(ThreadLocalData __tld, Object x, Object y, Cons nums) throws Exception {
            if (__tld == null) __tld = ThreadLocalData.get();
            return Reflector.invokeStaticMethod("multiply", "org.clojure.runtime.Num", new Object[]{Reflector.invokeStaticMethod("multiply", "org.clojure.runtime.Num", new Object[]{x, y}), clojure__apply.fn.invoke(__tld, COMMON_LISP__PLUS__.getValue(__tld), nums)});
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* 1+ ((x) (.onePlus x)))

*/

    static public class NUM__1PLUS__ extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            return ((IFn) ACC__clojure__onePlus).invoke(__tld, x);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* 1- ((x) (.oneMinus x)))

*/

    static public class NUM__1_ extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            return ((IFn) ACC__clojure__oneMinus).invoke(__tld, x);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* integer? ((x) (instance? x IntegerNum.)))

*/

    static public class integerQMARK__ extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            return (x instanceof org.clojure.runtime.IntegerNum ? RT.T : null);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* neg? ((x) (.minusp x)))

*/

    static public class negQMARK__ extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            return ((IFn) ACC__clojure__minusp).invoke(__tld, x);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* num? ((x) (instance? x Num.)))

*/

    static public class numQMARK__ extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            return (x instanceof org.clojure.runtime.Num ? RT.T : null);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* pos? ((x) (.plusp x)))

*/

    static public class posQMARK__ extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            return ((IFn) ACC__clojure__plusp).invoke(__tld, x);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* zerop ((x) (= x Num.ZERO)))

*/

    static public class zerop extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            return COMMON_LISP__EQ__.fn.invoke(__tld, x, Reflector.getStaticField("ZERO", "org.clojure.runtime.Num"));
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 =
 ((x) t)
 ((x y) (Num.equiv x y))
 ((x y & rest) (and (Num.equiv x y) (apply = y rest))))

*/

    static public class EQ__ extends RestFn2 {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            return RT.T;
        }

        public Object invoke(ThreadLocalData __tld, Object x, Object y) throws Exception {
            return Reflector.invokeStaticMethod("equiv", "org.clojure.runtime.Num", new Object[]{x, y});
        }

        public Object doInvoke(ThreadLocalData __tld, Object x, Object y, Cons rest) throws Exception {
            if (__tld == null) __tld = ThreadLocalData.get();
            return (((Reflector.invokeStaticMethod("equiv", "org.clojure.runtime.Num", new Object[]{x, y}) != null)) ? clojure__apply.fn.invoke(__tld, COMMON_LISP__EQ__.getValue(__tld), y, rest) : null);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 <
 ((X) T)
 ((X Y) (Num.lt X Y))
 ((X Y & REST) (and (Num.lt X Y) (apply < Y REST))))

*/

    static public class LT__ extends RestFn2 {
        public Object invoke(ThreadLocalData __tld, Object X) throws Exception {
            if (__tld == null) __tld = ThreadLocalData.get();
            return COMMON_LISP__T.getValue(__tld);
        }

        public Object invoke(ThreadLocalData __tld, Object X, Object Y) throws Exception {
            return Reflector.invokeStaticMethod("lt", "org.clojure.runtime.Num", new Object[]{X, Y});
        }

        public Object doInvoke(ThreadLocalData __tld, Object X, Object Y, Cons REST) throws Exception {
            if (__tld == null) __tld = ThreadLocalData.get();
            return (((Reflector.invokeStaticMethod("lt", "org.clojure.runtime.Num", new Object[]{X, Y}) != null)) ? clojure__apply.fn.invoke(__tld, COMMON_LISP__LT__.getValue(__tld), Y, REST) : null);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 <=
 ((X) T)
 ((X Y) (Num.lte X Y))
 ((X Y & REST) (and (Num.lte X Y) (apply <= Y REST))))

*/

    static public class LT__EQ__ extends RestFn2 {
        public Object invoke(ThreadLocalData __tld, Object X) throws Exception {
            if (__tld == null) __tld = ThreadLocalData.get();
            return COMMON_LISP__T.getValue(__tld);
        }

        public Object invoke(ThreadLocalData __tld, Object X, Object Y) throws Exception {
            return Reflector.invokeStaticMethod("lte", "org.clojure.runtime.Num", new Object[]{X, Y});
        }

        public Object doInvoke(ThreadLocalData __tld, Object X, Object Y, Cons REST) throws Exception {
            if (__tld == null) __tld = ThreadLocalData.get();
            return (((Reflector.invokeStaticMethod("lte", "org.clojure.runtime.Num", new Object[]{X, Y}) != null)) ? clojure__apply.fn.invoke(__tld, COMMON_LISP__LT__EQ__.getValue(__tld), Y, REST) : null);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 >
 ((X) T)
 ((X Y) (Num.gt X Y))
 ((X Y & REST) (and (Num.gt X Y) (apply > Y REST))))

*/

    static public class GT__ extends RestFn2 {
        public Object invoke(ThreadLocalData __tld, Object X) throws Exception {
            if (__tld == null) __tld = ThreadLocalData.get();
            return COMMON_LISP__T.getValue(__tld);
        }

        public Object invoke(ThreadLocalData __tld, Object X, Object Y) throws Exception {
            return Reflector.invokeStaticMethod("gt", "org.clojure.runtime.Num", new Object[]{X, Y});
        }

        public Object doInvoke(ThreadLocalData __tld, Object X, Object Y, Cons REST) throws Exception {
            if (__tld == null) __tld = ThreadLocalData.get();
            return (((Reflector.invokeStaticMethod("gt", "org.clojure.runtime.Num", new Object[]{X, Y}) != null)) ? clojure__apply.fn.invoke(__tld, COMMON_LISP__GT__.getValue(__tld), Y, REST) : null);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn*
 >=
 ((X) T)
 ((X Y) (Num.gte X Y))
 ((X Y & REST) (and (Num.gte X Y) (apply >= Y REST))))

*/

    static public class GT__EQ__ extends RestFn2 {
        public Object invoke(ThreadLocalData __tld, Object X) throws Exception {
            if (__tld == null) __tld = ThreadLocalData.get();
            return COMMON_LISP__T.getValue(__tld);
        }

        public Object invoke(ThreadLocalData __tld, Object X, Object Y) throws Exception {
            return Reflector.invokeStaticMethod("gte", "org.clojure.runtime.Num", new Object[]{X, Y});
        }

        public Object doInvoke(ThreadLocalData __tld, Object X, Object Y, Cons REST) throws Exception {
            if (__tld == null) __tld = ThreadLocalData.get();
            return (((Reflector.invokeStaticMethod("gte", "org.clojure.runtime.Num", new Object[]{X, Y}) != null)) ? clojure__apply.fn.invoke(__tld, COMMON_LISP__GT__EQ__.getValue(__tld), Y, REST) : null);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* prn ((x) (.println System.out x)))

*/

    static public class prn extends AFn {
        public Object invoke(ThreadLocalData __tld, Object x) throws Exception {
            return ((IFn) ACC__clojure__println).invoke(__tld, Reflector.getStaticField("out", "java.lang.System"), x);
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* fact ((n) (if (= n 1) 1 (* n (fact (1- n))))))

*/

    static public class fact extends AFn {
        public Object invoke(ThreadLocalData __tld, Object n) throws Exception {
            if (COMMON_LISP__EQ__.fn.invoke(__tld, n, Num.ONE) != null) {
                return Num.ONE;
            } else {
                return COMMON_LISP__STAR__.fn.invoke(__tld, n, clojure__fact.fn.invoke(__tld, COMMON_LISP__NUM__1_.fn.invoke(__tld, n)));
            }
        }
    }
/* Generated by Clojure from the following Lisp:

(defn* fmain ((args) (prn (fact 50))))

*/

    static public class fmain extends AFn {
        public Object invoke(ThreadLocalData __tld, Object args) throws Exception {
            return clojure__prn.fn.invoke(__tld, clojure__fact.fn.invoke(__tld, Num.from(50)));
        }
    }
/* Generated by Clojure from the following Lisp:

(defmain fmain)

*/

    static public void main(String[] args) {
        try {
            clojure__fmain.fn.invoke(ThreadLocalData.get(), args);
        } catch (Exception ex) {
        }
    }

    static Symbol SYM__t = Symbol.intern("t");
    static Keyword KEY__key = Keyword.intern("key");
    static Keyword KEY__test = Keyword.intern("test");
    static Var clojure__fmain = Namespace.internVar("clojure", "fmain");
    static Var clojure__prn = Namespace.internVar("clojure", "prn");
    static Var COMMON_LISP__NUM__1_ = Namespace.internVar("COMMON_LISP", "NUM__1_");
    static Var clojure__fact = Namespace.internVar("clojure", "fact");
    static Var COMMON_LISP__STAR__ = Namespace.internVar("COMMON_LISP", "STAR__");
    static Var COMMON_LISP__GT__ = Namespace.internVar("COMMON_LISP", "GT__");
    static Var COMMON_LISP__LT__EQ__ = Namespace.internVar("COMMON_LISP", "LT__EQ__");
    static Var COMMON_LISP__LT__ = Namespace.internVar("COMMON_LISP", "LT__");
    static Var COMMON_LISP__T = Namespace.internVar("COMMON_LISP", "T");
    static Var COMMON_LISP__EQ__ = Namespace.internVar("COMMON_LISP", "EQ__");
    static Var COMMON_LISP___ = Namespace.internVar("COMMON_LISP", "_");
    static Var COMMON_LISP__PLUS__ = Namespace.internVar("COMMON_LISP", "PLUS__");
    static Var COMMON_LISP__NUM__1PLUS__ = Namespace.internVar("COMMON_LISP", "NUM__1PLUS__");
    static Var clojure__pop = Namespace.internVar("clojure", "pop");
    static Var COMMON_LISP__GT__EQ__ = Namespace.internVar("COMMON_LISP", "GT__EQ__");
    static Var clojure__nullQMARK__ = Namespace.internVar("clojure", "nullQMARK__");
    static Var clojure__last = Namespace.internVar("clojure", "last");
    static Var clojure__copy_tree = Namespace.internVar("clojure", "copy_tree");
    static Var clojure__reverse = Namespace.internVar("clojure", "reverse");
    static Var clojure__nthcdr = Namespace.internVar("clojure", "nthcdr");
    static Var clojure__nreverse = Namespace.internVar("clojure", "nreverse");
    static Var clojure__butlast = Namespace.internVar("clojure", "butlast");
    static Var clojure__rest = Namespace.internVar("clojure", "rest");
    static Var clojure__ffirst = Namespace.internVar("clojure", "ffirst");
    static Var clojure__first = Namespace.internVar("clojure", "first");
    static Var clojure__consQMARK__ = Namespace.internVar("clojure", "consQMARK__");
    static Var clojure__atomQMARK__ = Namespace.internVar("clojure", "atomQMARK__");
    static Var clojure__eql = Namespace.internVar("clojure", "eql");
    static Var clojure__y = Namespace.internVar("clojure", "y");
    static Var clojure__fn = Namespace.internVar("clojure", "fn");
    static Var clojure__assoc_if = Namespace.internVar("clojure", "assoc_if");
    static Var clojure__assoc = Namespace.internVar("clojure", "assoc");
    static Var clojure__append = Namespace.internVar("clojure", "append");
    static Var clojure__copy_list = Namespace.internVar("clojure", "copy_list");
    static Var clojure__nconc = Namespace.internVar("clojure", "nconc");
    static Var clojure__member = Namespace.internVar("clojure", "member");
    static Var clojure__cons = Namespace.internVar("clojure", "cons");
    static Var clojure__apply = Namespace.internVar("clojure", "apply");
    static Var clojure__spreadSTAR__ = Namespace.internVar("clojure", "spreadSTAR__");
    static Var clojure____tld = Namespace.internVar("clojure", "__tld");
    static Accessor ACC__clojure__println = Namespace.internAccessor("clojure", "println");
    static Accessor ACC__clojure__plusp = Namespace.internAccessor("clojure", "plusp");
    static Accessor ACC__clojure__minusp = Namespace.internAccessor("clojure", "minusp");
    static Accessor ACC__clojure__oneMinus = Namespace.internAccessor("clojure", "oneMinus");
    static Accessor ACC__clojure__onePlus = Namespace.internAccessor("clojure", "onePlus");
    static Accessor ACC__clojure__rest = Namespace.internAccessor("clojure", "rest");
    static Accessor ACC__clojure__first = Namespace.internAccessor("clojure", "first");
    static Accessor ACC__clojure__equals = Namespace.internAccessor("clojure", "equals");
    static Accessor ACC__clojure__applyTo = Namespace.internAccessor("clojure", "applyTo");

    static {
        try {
            Namespace.internVar("clojure", "fmain").bind(new fmain());
            Namespace.internVar("clojure", "fact").bind(new fact());
            Namespace.internVar("clojure", "prn").bind(new prn());
            Namespace.internVar("COMMON_LISP", "GT__EQ__").bind(new GT__EQ__());
            Namespace.internVar("COMMON_LISP", "GT__").bind(new GT__());
            Namespace.internVar("COMMON_LISP", "LT__EQ__").bind(new LT__EQ__());
            Namespace.internVar("COMMON_LISP", "LT__").bind(new LT__());
            Namespace.internVar("COMMON_LISP", "EQ__").bind(new EQ__());
            Namespace.internVar("clojure", "zerop").bind(new zerop());
            Namespace.internVar("clojure", "posQMARK__").bind(new posQMARK__());
            Namespace.internVar("clojure", "numQMARK__").bind(new numQMARK__());
            Namespace.internVar("clojure", "negQMARK__").bind(new negQMARK__());
            Namespace.internVar("clojure", "integerQMARK__").bind(new integerQMARK__());
            Namespace.internVar("COMMON_LISP", "NUM__1_").bind(new NUM__1_());
            Namespace.internVar("COMMON_LISP", "NUM__1PLUS__").bind(new NUM__1PLUS__());
            Namespace.internVar("COMMON_LISP", "STAR__").bind(new STAR__());
            Namespace.internVar("COMMON_LISP", "_").bind(new _());
            Namespace.internVar("COMMON_LISP", "PLUS__").bind(new PLUS__());
            Namespace.internVar("clojure", "listSTAR__").bind(new listSTAR__());
            Namespace.internVar("clojure", "spreadSTAR__").bind(new spreadSTAR__());
            Namespace.internVar("clojure", "list").bind(new list());
            Namespace.internVar("clojure", "last").bind(new last());
            Namespace.internVar("clojure", "copy_tree").bind(new copy_tree());
            Namespace.internVar("clojure", "copy_list").bind(new copy_list());
            Namespace.internVar("clojure", "consQMARK__").bind(new consQMARK__());
            Namespace.internVar("clojure", "cons").bind(new cons());
            Namespace.internVar("clojure", "rrest").bind(new rrest());
            Namespace.internVar("clojure", "frest").bind(new frest());
            Namespace.internVar("clojure", "ffirst").bind(new ffirst());
            Namespace.internVar("clojure", "rest").bind(new rest());
            Namespace.internVar("clojure", "first").bind(new first());
            Namespace.internVar("clojure", "butlast").bind(new butlast());
            Namespace.internVar("clojure", "atomQMARK__").bind(new atomQMARK__());
            Namespace.internVar("clojure", "assoc_if").bind(new assoc_if());
            Namespace.internVar("clojure", "assoc").bind(new assoc());
            Namespace.internVar("clojure", "append").bind(new append());
            Namespace.internVar("clojure", "adjoin").bind(new adjoin());
            Namespace.internVar("clojure", "acons").bind(new acons());
            Namespace.internVar("clojure", "nullQMARK__").bind(new nullQMARK__());
            Namespace.internVar("clojure", "not").bind(new not());
            Namespace.internVar("clojure", "equals").bind(new equals());
            Namespace.internVar("clojure", "equal").bind(new equal());
            Namespace.internVar("clojure", "eql").bind(new eql());
            Namespace.internVar("clojure", "eq").bind(new eq());
            Namespace.internVar("clojure", "identity").bind(new identity());
            Namespace.internVar("clojure", "constantly").bind(new constantly());
            Namespace.internVar("clojure", "complement").bind(new complement());
            Namespace.internVar("clojure", "apply").bind(new apply());
        } catch (Exception e) {
        }
    }

    public static void __init() {
    }
}

